---
layout: post
title:  "React"
description: An introduction of what docker is & the basic commonds.
date:   2021-06-08 21:03:36 +0530
categories: React javaScript
---
This post demonstrates the concepts of `React`and its general use. The basic operations of `React` will be demonstrated.

# Overview

## Introducing to `JSX`

Consider this variable declaration:

```jsx
const element = <h1>Hello, world!</h1>;
```

This funny tag syntax is neither a string nor HTML.

It is called ``JSX``, and it is a syntax extension to JavaScript. We  recommend using it with React to describe what the UI should look like. `` JSX`` may remind you of a template language, but it comes with the full  power of *JavaScript*.

`JSX` produces React “*elements*”. We will explore rendering them to the **DOM** in the [next section](https://reactjs.org/docs/rendering-elements.html). Below, you can find the basics of `JSX` necessary to get you started.

### Why JSX

**React** embraces the fact that rendering logic is inherently coupled  with other UI logic: how events are handled, how the state changes over  time, and how the data is prepared for display.

Instead of artificially separating *technologies* by putting markup and logic in separate files, React [separates *concerns*](https://en.wikipedia.org/wiki/Separation_of_concerns) with loosely coupled units called “components” that contain both. We will come back to components in a [further section](https://reactjs.org/docs/components-and-props.html), but if you’re not yet comfortable putting markup in `JS`, [this talk](https://www.youtube.com/watch?v=x7cQ3mrcKaY) might convince you otherwise.

React [doesn’t require](https://reactjs.org/docs/react-without-jsx.html) using `JSX`, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more  useful error and warning messages.

+ In the example below, we declare a variable called `name` and then use it inside `JSX` by wrapping it in curly braces:

  ```jsx
  const element = <h1>Hello, {name}</h1>;
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
  ```

​		You can put any valid [JavaScript expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions) inside the curly braces in `JSX`. For example, `2 + 2`, `user.firstName`, or `formatName(user)` are all valid JavaScript expressions.

+ In the example below, we embed the result of calling a JavaScript function, `formatName(user)`, into an `<h1>` element。

  ```jsx
  function formatName(user) {
    return user.firstName + ' ' + user.lastName;
  }
  
  const user = {
    firstName: 'Harper',
    lastName: 'Perez'
  };
  
  const element = (
    <h1>
      Hello, {formatName(user)}!  
    </h1>
  );
  
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
  ```

## *JSX* is an Expression Too 

After compilation, `JSX` expressions become regular JavaScript function calls and evaluate to JavaScript objects.

This means that you can use *JSX* inside of `if` statements and `for` loops, assign it to variables, accept it as arguments, and return it from functions:

```jsx
function getGreeting(user) {
  if (user) {
    return <h1>Hello, {formatName(user)}!</h1>;  }
  return <h1>Hello, Stranger.</h1>;}
```

### Specifying Attributes with *JSX*

You may use quotes to specify string literals as attributes:

```jsx
const element = <div tabIndex="0"></div>;
```

You may also use curly braces to embed a JavaScript expression in an attribute:

```jsx
const element = <img src={user.avatarUrl}></img>;
```

### Specifying Children with *JSX*

If a tag is empty, you may close it immediately with `/>`, like XML:

```jsx
const element = <img src={user.avatarUrl} />;
```

*JSX* tags may contain children:

```jsx
const element = (
  <div>
    <h1>Hello!</h1>
    <h2>Good to see you here.</h2>
  </div>
);
```

### Conditional rendering:

#### if-else conditional rendering:

```jSX
const loadData = () =>{
    if (isLoading) {
        return<div>loading...</div>
    }
    return <div>Loading finished, here is the place to display data.</div>
}
```

#### ternary operator conditional rendering:

```jSX
const loadData = () =>{
	return isLoading ? (<div>loading...</div>) : (<div>Loading finished, here is the place to display data.</div>)
}
```

#### && conditional rendering

```jsx
const loadData = () =>{
    return isLoading && (<div>loading...</div>)
}
```

### List Rendering

- Use `map()` method to render a list of data
- cautious: add key entity when rendering a list, and the value of key should be unique      
- avoid use index as key

```jsx
const songs = [
    {id: 1, name: 'My love'},
    {id: 2, name: "Transpassing"},
    {id: 3, name: 'Uptown Funk'},
]
```

To render this list in the page, use `<ul>{songs.map(item => <li key={item.id}>item.name</li>)}</ul>` in the `JSX`.

### Style bound 

To bound style with `CSS`, we should first create a class name in the corresponding tag. Then, we can import the targeted `CSS` file. For example, we can create `index.css`, then, write:


```css
.list{
test-aligh: center
}
```

In `index.js`, we can add parameters in our <ul> tag. `<ul classname='list' style={ {color: 'red', backgroundColor: 'skyblue'}}>{songs.map(item => <li key={item.id}>item.name</li>)}</ul>`

### After the three examples, the generated code should look like:

```jsx
// Use JSX to transfer JS variables into the JSX
const name = "Danny"
const age = 19
const isLoading = true

// ternary operator conditional rendering:
const loadData = () =>{
    return isLoading ? (<div>loading...</div>) : (<div>Loading finished, here is the place to display data.</div>)
}

// List rendering:
const songs = [
    {id: 1, name: 'My love'},
    {id: 2, name: "Transpassing"},
    {id: 3, name: 'Uptown Funk'},
]

const title1 = (
    <div className="title">
        Hello JSX, {name}, age: {age}
        <h1>
            Conditional rendering:
            {loadData()}
        </h1>
        <ul className="list" style={ {color: 'red', backgroundColor: 'skyblue'} }>
            {songs.map(item => <li key={item.id}>{item.name}</li>)}
        </ul>
    </div>

)

// render react element
ReactDOM.render(title1, document.getElementById('root'))
```

 Then when running `npm start`, the page rendering in the browser looks like:<img src="https://img-blog.csdnimg.cn/4b065341137947cf9897f803a4743323.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="react1JSX" style="zoom:60%;" />

## React component Creation

#### use function to creation component

+ The component using ***JS*** function is called: function component
+ Function components must have returning value
+ The first letter of the component name must be upper-case, **React** uses this to distinguish the differences between component and a normal React element.   

For example:

```jsx
funcfunction Hello() {
    return(
        <div>This is the first function component</div>
    )
}

```

Or you can simplify the syntax:

```jsx
const Hello = () => <div>This is the first component</div>
```

#### use class to create a React component

+ **Class component**: the component used by ES6
+ First letter of a class name must be upper case
+  Class component should inherit `React.Component` super class to get the method provided by ***super()***.
+ Class component must provide `render()` method
+ `render()` must have returning value

```jsx
class HelloClass extends React.Component {
    render() {
        return (
            <div>This is the first class component</div>
        )
    }
}
```

In the **index.htm**l, we can add a tag `<div id='hello'></div>`, then we can add:

```jsx
ReactDOM.render(<HelloClass />, document.getElementById('hello'))
```

### Write a independent `JS` file to include class component

+ Create `Hello.js`
+ Import *React* in to `Hello.js`
+ Write component or class
+ Export this component
+ Import this component in `index.js`
+ Render this component

In the new `Hello.js`:

```jsx
import React from 'react'

// make a new component
class Hello_com extends React.Component{
    render() {
        return <div>This is the first imported component</div>
    }
}

// export component
export default Hello_com
```

Then, we need to import this file into `index.js` and render it directly.

```jsx
// import Hello component
import Hello_com from "./Hello";

ReactDOM.render(<Hello_com />, document.getElementById('hello_com') )
```

### React Event handling

#### Event binding:

1. Syntax: ***on + event name = {event handling process}***, such as `onClick={()=>{}}`
2. Cautious: *React* event handling uses  *Hump nomenclature*, such as: onMouseEnter, onFocus......

+ Event binding as a class:

  ```jsx
  // event handling
  class eventHandle extends React.Component {
      handleClick(){
          console.log("Clicking.... ")
      }
      // Envent handler
      render() {
          return (
              <button onClick={this.handleClick}>Hit me!!</button>
          )
      }
  }
  ```

+ Event binding as a function:

  ```jsx
  function event_handle(){
      function handleClick(){
          console.log("Clicking.... ")
      }
      return(
          <button onClick={handleClick}>Hit me!!</button>
      )
  }
  ```

#### Event Object

1. We can get event object through the parameter of the event handling function

2. Event objects in *React* are called **Synthetic event (object) **

3. Synthetic events: They are compatible with all the browsers, there is no need to worry about the problem of cross-browser problem.

   Assume we have a function to prevent the default behavior of the browser:

   ```jsx
   function handleClick(e){
       // prevent the default behavior of the browser
       e.preventDefault()
       console.log("Clicking.... ")
   }
   ```

   if we click on the button which calls this function:

   ```jsx
    <a href="https://www.baidu.com" onClick={handleClick}>
               Click this to not jump to baidu
           </a>
   ```

   Then, it will not jump to baidu.

### Stateful component && Stateless component

+ *Function component* is called **Stateless component**, while *class component* is called **Stateful component**
+ **State** is relevant to **data**
+ *Function component* has no state, only responsible to show **Static data**
+ *Class component* has its own state, responsible for refreshing UI, which let the data flow

#### *State* && *setState* in component

##### Usage of *state* :

+ **state** is relevant to **data**

+ **state** is private, only accessible in the inner structure of component

+ Use `this.state` to get its value

  ```jsx
  class Hello_com extends React.Component{
      state = {
          count:0
      }
      render() {
          return <div>This is the first stateful imported component, {this.state.count}</div>
      }
  }
  ```

##### *setState()* to change state

+ *state* can be changed

+ Syntax: this.setState({value to be changed})

+ Cautious: Do not try to change the value in *state*, which is prohibited

+ effect of `setState()`:  1. Change *State* 2. **Refresh UI**

+ It is a reflection of data driven view

   ```jsx
   class Hello_com extends React.Component {
       state = {
           count: 0,
           test: "this will not change"
       }
   
       render() {
           return (
               <div>
                   <h1><a>
                       This is the first stateful imported component
                   </a>
                       couter: {this.state.count}
                       <h2>
                           test: {this.state.test}
                       </h2>
                   </h1>
                   <button onClick={() => {
                       this.setState({
                           count: this.state.count + 1
                       })
                   }}>+1
                   </button>
               </div>
           )
       }
   }
   ```

##### Detach the event handling function out from the *JSX* structure

+ We can write a independent function `onIncrement()` in the class

  ```jsx
  onIncrement(){
          this.setState({
              count: this.state.count + 1
          })
      }
  ```

  Then, the button in the *JSX* structure becomes:

  ```jsx
  <button onClick={this.onIncrement}>+1</button>
  ```

  However, when running the program, there is an Error:

  <img src="https://img-blog.csdnimg.cn/20210713155352405.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="JSXError1" style="zoom:60%;" />

<center>Error when calling onIncrement()</center>

This is because originally we are using abbreviated function calling method:

` <button onClick={() => {this.setState({count: this.state.count + 1})}}>+1` in the event handling method, and `()=>{}` this kind of method calling does not contain *this* inside, thus, the *this* of this abbreviated calling method will find its parent method `render()`, and this super class has a `setState()` method. However, when we detach the method to outside, the value of `this` changes. 

##### Solutions

1. Arrow function:

   Arrow function doesn't contain this.

   ```jsx
   <button onClick={() => this.onIncrement()}>+1</button>
   ```

2. *Function.prototype.bind()*:

   ```jsx
   constructor() {
           super();
           this.state = {
               count: 0,
               test: "this will not change"
           }
           this.onIncrement = this.onIncrement.bind(this)
       }
   ```

   Then, in the *JSX* below, we can use:

   ```jsx
   <button onClick={this.onIncrement}>+1</button>
   ```

3. Use arrow function as class instantiated method:

   ```jsx
   onIncrement=() => {
           console.log("clicking....")
           this.setState({
               count: this.state.count + 1
           })
       }
   ```

### Form Processing

#### Controlled component

+ Form element in HTML is importable, which is said to have its own state.
+ However, the changeable *State* value usually stores in *state* variable, and it can only be modified through `setState()` method.
+ *React* binds *State* with from element value, and it can control form value through *State* value.
+ **Controlled component**: The form element whose value is controlled by *React*.

##### Steps:

1. Add a *State* to represent the value of the form element. (In charge of the source of the form element)

   ```jsx
    state = {
           txt: 'aaaaaaaaa'
       }
   
   ```

2. Bind the element with **Change event**, and set the value of the form element to be the value of *State*. (In charge of the change of the element value)

   ```jsx
   <input type="text" value={this.state.txt} onChange={this.handleChange} />
   ```

   Event handler:

   ```jsx
   handleChange = e =>{
           this.setState(
               {
                   txt: e.target.value
               }
           )
       }
   ```

   For text, text area, pull down menu, we can operate through `e.target.value`, for check box, we can operate on `e.target.checked`. Below is an example of operations on controlled elements:

   ```jsx
   import React from 'react'
   
   // Form processing
   
   class Form_process extends React.Component {
       state = {
           txt: 'aaaaaaaaa',
           content: '',
           city: 'bj',
           isChecked: false
       }
   
       // Handle change in the text input
       handleChange = e => {
           this.setState(
               {
                   txt: e.target.value
               }
           )
       }
   
       // Handle change in the text area
       handleContent = e => {
           this.setState(
               {
                   content: e.target.value
               }
           )
       }
   
       // Handle pull down menu
       handleCity = e => {
           this.setState(
               {
                   city: e.target.value
               }
           )
       }
   
       // Handle the change in check box
       handleChecked = e =>{
           this.setState(
               {
                   isChecked: e.target.checked
               }
           )
       }
   
       render() {
           return (
               <div>
                   {/*{ text }*/}
                   <input type="text" value={this.state.txt} onChange={this.handleChange}/>
                   <br/>
   
                   {/* text area */}
                   <textarea value={this.state.content} onChange={this.handleContent}/>
                   <br/>
   
                   {/*  pull down menu  */}
                   <select value={this.state.city} onChange={this.handleCity}>
                       <option value="sh">Shanghai</option>
                       <option value="bj">Beijing</option>
                       <option value="gz">Guangzhou</option>
                   </select>
   
                   {/*  check box  */}
                   <input type="checkbox" checked={this.state.isChecked} onChange={this.handleChecked}/>
               </div>
           )
       }
   }
   
   export default Form_process
   ```

   Then we can handle changes in the form on the page:

   

<img src="https://img-blog.csdnimg.cn/20210713155517804.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="formHTML" style="zoom:60%;" />![formHandle](D:\pc\Pictures\formHandle.PNG)

To integrate the event handler into one method:

1. Add *name* entity in form element which is the same as the *state* name to distinguish from others.

2. Obtain the corresponding value according to the type of form element.



3. Change the corresponding *state* in *Change* event handler through `[name]`.

   ```jsx
   class Form_process extends React.Component {
       state = {
           txt: 'aaaaaaaaa',
           content: '',
           city: 'bj',
           isChecked: false
       } 
   
   handleForm = e => {
   
           // obtain the current DOM object
           const target = e.target
   
           // Obtain the corresponding value through its type
           const value = target.type === 'checkbox'
               ? target.checked
               : target.value
   
           // Obtain the name
           const name =target.name
   
           this.setState({
               [name]: value
           })
       }
    
    render() {
           return (
               <div>
                   {/*{ text }*/}
                   <input type="text" name='txt' value={this.state.txt} onChange={this.handleForm}/>
                   <br/>
   
                   {/* text area */}
                   <textarea value={this.state.content} name='content' onChange={this.handleForm}/>
                   <br/>
   
                   {/*  pull down menu  */}
                   <select value={this.state.city} name='city' onChange={this.handleForm}>
                       <option value="sh">Shanghai</option>
                       <option value="bj">Beijing</option>
                       <option value="gz">Guangzhou</option>
                   </select>
   
                   {/*  check box  */}
                   <input type="checkbox" checked={this.state.isChecked} name='isChecked' onChange={this.handleForm}/>
               </div>
           )
       }
   }
   ```


## Communication Between Components

Components are independent units, which can only own its own data. When we break our functions into several parts, we modularize our functions, so that we can better achieve our functions. During this process, different components unavoidably need to share their properties with each other. To realize these functions, we need to break out the encapsulation of each component, to let them communicate with out side. This process is called components comminication.

### Props

+ Components are encapsualated
+ Function of **props**: Receive the data passed to components
+ Passing data: Add properties to tags
+ Receive data: *Function components* receive data through parameter `props`, *Class components* via `this.props`.
+ We can pass any type of data through **props**
+ **props** can only be read, not be modified
+ When using class components, if we write a *constructor*, we should pass `props` to `super()`. Otherwise, we cannot get `props` via constructor

Example of passing **props** though function:

```jsx
import React from "react";
import ReactDOM from 'react-dom';

/*
    props
 */

//Receive data

const Hello = (props) => {
    console.log(this.props)

    return(
        <div>
            <h1>props:  </h1>
        </div>
    )
}

// Passing data
ReactDOM.render(<Hello name='Jack' age={19}/>, document.getElementById('props'))
```

Example of passing **props** through class:

```jsx
class Props extends React.Component {
    render() {
        // console.log(this.props)
        constructor(props) {
        // Recommend to pass props to Constructor
        super(props);
    }
        this.props.fn() // passing a function
        return(
            <div>
                <h1>props: {this.props.age}</h1>
            </div>
        )
    }
}

// Passing data through props
ReactDOM.render(<Props name='Jack' age={19} colors={['red','blue','green']} fn={() => console.log('This is a function')}/>, document.getElementById('props'))
```

###  Three means of communication between components

1. Parent => child

   1. Parent provide **state** data
   2. Add parameter to child component tag, whose value is the data in **state**
   3. Child component receives the data passed by parent component

   ```jsx
   class Parent extends React.Component{
       state = {
           firstName: 'Wong',
           lastName: 'Yeah'
       }
       render() {
           return(
               <div>
                   Pass data to child components: <Child firstName={this.state.firstName} lastName={this.state.lastName}/>
               </div>
           )
       }
   }
   
   const Child = props => {
       console.log("Child props",props)
       return(
           <div className="child">
               <p>Child component, receiving data passed by pappa: {props.firstName}</p>
           </div>
       )
   }
   ```

2. Child => Parent

   Use **callback function**, parent component **provides** callback, child function use that callback function, set the parameter of the callback function to be the data to be passed

   1. parent provides a callback function (To receive data)
   2. pass this function to child component by using **props**
   3. child component call callback function by using **props**
   4. pass data back to parent component through child component's parameter

   ```jsx
   // data from Child component to parent component:
   class Parent1 extends React.Component {
       state = {
           parentMsg: ''
       }
   
       // Provide callback function, to receive data
       getChildMsg = data => {
           console.log('receiving msg from child: ', data)
           this.setState({
               parentMsg: data
           })
       }
   
       render() {
           return(
               <div className='parent'>
                   Pappa component: {this.state.parentMsg}
                   <Child1 getMsg={this.getChildMsg} /> // pass call back function to child
               </div>
           )
       }
   }
   
   // child class
   class Child1 extends React.Component{
       state = {
           msg: 'save Me!'
       }
       handleClick = () => {
           // call the callback function sent by parent component
           this.props.getMsg(this.state.msg)
       }
       
       render() {
           return(
               <div className='child'>
                   child component: {' '}
                   <button onClick={this.handleClick}>
                       hit me to send data to parent component!!!
                   </button>
               </div>
           )
       }
   ```
   
3. Children => Children

   1. Promote the sharing states to the nearest **public parent component**, and let the public parent component control this state
   2. Strategy: Promote the sharing states
   3. responsibilities of parent component: 
      1. Provide sharing state
      2. Provide the function to operate the sharing state 

   The below example is to show a simple counter on browse:

   ```jsx
   // Children to Children
   class Counter extends React.Component {
       // Provide sharing state
       state = {
           count: 0
       }
   
       // Provide a method to change state
       onIncrement = () => {
           console.log("Heeeeeaaaa!!!!")
           this.setState({
               count: this.state.count + 1
           })
       }
   
       render() {
           return (
               <div>
                   <Child2 count={this.state.count}/>
                   <Child3 onIncrement={this.onIncrement}/>
               </div>
           )
       }
   }
   
   const Child2 = props => {
       return <h1>Counter: {props.count}</h1>
   }
   
   const Child3 = (props) => {
       return <button onClick={() => props.onIncrement()}>+1</button>
   }
   ```

<img src="https://img-blog.csdnimg.cn/80a9d86c90f848d48ab653e6bb08384b.PNG" alt="ReactCounter" style="zoom:60%;" />

### Context

What should we do if we need to transfer data from **App** which is the outer node to the inner node **Child**?

+ We can apply **Context**

+ Function: Transfer data across Components (Such as: Theme, Language)

  <img src="https://img-blog.csdnimg.cn/6ecfc3d46e1548cb8fe6521bf22b731c.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="Context" style="zoom:67%;" />

<center>Transfer Process</center>

Steps:

1. Call `React.createContext()` to create **Provider** (to provide data) and **Consumer** (to receive data) these two components

   ```jsx
   const {Provider, Consumer} = React.createContext
   ```

2. Use Provider as the **Parent Node**

   ```jsx
   <Provider>
       <div className='context'>
           <Node />
       </div>
   </Provider>
   ```

3. Set a **value** property, which is represented as the data to be passed

   ```jsx
   <Provider value='pink'>
   ```

4. Call **Consumer** to receive data

   ```jsx
   <Consumer>
       {data => <span>I am a Child Node -- {data}</span>}
   </Consumer>
   ```

For example, in the below components,  between **Provider** and **Consumer**, there are nested components which are respectively **Node** && **SubNode**, thus, it is not so clear to transfer data through this nested structure by passing **props** layer by layer. We use **Provider** and **Consumer** to transfer data.  

```jsx
import React from 'react'
import * as ReactDOM from "react-dom";

/*
    Context
 */

const {Provider, Consumer} = React.createContext()

class Context extends React.Component {
    render() {
        return (
            <Provider value='pink'>
                <div className='context'>
                    <Node/>
                </div>
            </Provider>
        )
    }
}

const Node = props => {
    return (
        <div className='node'>
            <SubNode/>
        </div>
    )
}

const SubNode = props => {
    return (
        <div className='subnode'>
            <Child/>
        </div>
    )
}

const Child = props => {
    return (
        <div className='child'>
            <Consumer>
                {data => <span>I am a Child Node -- {data}</span>}
            </Consumer>
        </div>
    )
}

ReactDOM.render(<Context/>, document.getElementById('context'))
```

### **Children** property of **props**

+ **Children**: Represents the child Node of component tag. When the component tag has a child Node, **props** has this property.
+ **Children** is the same as normal **props**, the value of which can be any kind of value (Text, React const, component, even function)

```jsx
// Children property
const Children = props => {
    console.log(props)
    return(
        <div>
            <h1>The children node of this component: </h1>
            {props.children}
        </div>
    )
}

// Children is Text 
//ReactDOM.render(<Children>I am a children </Children>, document.getElementById('Children'))
// Children is a tag
ReactDOM.render(<Children>
        <p>I am a children node, which is a p tag</p>
    </Children>,
    document.getElementById('Children'))
```

### Props Check

When passing **Props** across components, users cannot know its type. If a user pass a props to a worry position which requires another specific type, the error cannot be prevented by observation. 

+ We can install an extra props checking tool via `npm i props-types`. 

+ Import `prop-type` in the project

+ Use `ComponentName.propTrpes = {}` to add checking rules for components

+ We can point our checking rules via `PropTypes` object.

  ```jsx
  import PropTypes from 'prop-types'
  
  // Using PropTypes to check props type error
  const CheckProp = props => {
      const arr = props.colors
      const list = arr.map((item, index) => <li key={index}>{item.name}</li> )
      return <ul>{list}</ul>
  }
  
  // add props checking rules
  CheckProp.propTypes = {
      // If the type of color is not an array, error will be generated, user can know exactly which type color needs
      colors: PropTypes.array
  }
  ReactDOM.render(<CheckProp colors={19} />, document.getElementById('props'))
  ```

  We can see that colors in the above code requires an *array*, however, we give a type of *Integer*, thus, error code generates:

  

<img src="https://img-blog.csdnimg.cn/3115ece23251467684c0e8f1fb01b98e.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="typeError" style="zoom:60%;" />

<center>Type error generated by PropTypes</center>

​	if we give the *colors* an *array* instead of an *Integer*, the error disappears. For example:

```jsx
ReactDOM.render(<CheckProp colors={['red', 'blue']} />, document.getElementById('props'))
```

+ Rule for **Props checking**

  1. Types: *array*, *bool*, *func*, *number*, *object*， *string*
  2. React component type: *element*
  3. Required: *isRequired*

  If we need to add *proptype checking* for one class for example:

  ```jsx
  // Add props type checking
  // type of a:      number
  // type of fn:     func and isRequired
  // type of tag:    element
  // type of filter: object: ({area:'Shanghai', price: 1999})
  
  CheckProp.propTypes = {
      a : PropTypes.number,
      fn : PropTypes.func.isRequired,
      tag: PropTypes.element,
      filter: PropTypes.shape({
          area: PropTypes.string,
          price: PropTypes.number
      })
  }
  ```


### Lifecycle of a component

+ Definition: The process of which **Components** are created and then loaded to run in a particular webpage, then destroyed if not being used.
+ Every sage of a lifecycle is accompanied by some functions, these functions are called ***hook function***
+  Function of ***hook function***: to provide chance for developers to handle components in multiple stages.
+ **Only class components have lifecycle**

#### Three stages of components' lifeCycle:

<img src="https://img-blog.csdnimg.cn/b58c417956ab4216ba37705ef4094c32.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="lifeCycle" style="zoom:67%;" />

<center>LifeCycle of a component</center>

1. On creation:

   Sequence of the three hook functions: 

   Constructor => render() => componentDidMount

   | Hook function     | Trigger Time                                   | Function                                                |
   | ----------------- | ---------------------------------------------- | ------------------------------------------------------- |
   | constructor       | First to trigger when the component is created | 1. Initialize *state*. 2. Bind `this` for event handler |
   | render            | Every time to refresh the component            | Render UI (Cautions: Do not call `setState()` )         |
   | componentDidMount | After DOM rendering                            | 1. Send *HttpRequest* (ajax) 2. Operate on *DOM*        |

2. On refreshing (Updating):

+ Triggers: 1. `SetState()`, `forceUpdate()`, when the component receive new`props`.

+ Any kind of the above three function changes, the components will be refreshed

+ Sequence: 

  render() => componentDidUpdate()

| Hook function      | Trigger Time                        | Function                                                     |
| ------------------ | ----------------------------------- | ------------------------------------------------------------ |
| render             | Every time to refresh the component | Render UI (The same as on create stage)                      |
| componentDIdUpdate | After components are updated        | 1.  Send *HttpRequest* 2. Operate on *DOM*  3. If need to call `setState()` to refresh state, it must be put in the same if condition, otherwise, it will be nested |



3. On Unmount:

   + Triggers: When the components disappear from a page

   | Hook function        | Trigger time | function                |
   | -------------------- | ------------ | ----------------------- |
   | componentWillUnmount | Uninstall    | Execute wiping out jobs |

For example: In the below instance, `HitTom` is a parent component, you can hit a button to hit Tom, at the same time, a timer will start, if the counter is larger than 3, 'Tom is dead!!!" will be displayed, meanwile, child component will be uninstalled and the timer will be stopped by `ComponentWillUmount()` .

```jsx
// Hook functions
class HitTom extends React.Component {

    // First to execute
    constructor(props) {
        super(props)
        this.state = {
            count: 0
        }
    }

    handleClick = () => {
        this.setState({
            count: this.state.count + 1
        })
    }

    render() {
        return (
            <div>
                {
                    this.state.count > 3
                        ? <p>Tom is dead!!!</p>
                        : <LifeCycle count={this.state.count}/>
                }
                <button onClick={this.handleClick}>Hit Tom!!!</button>
            </div>
        )
    }
}

class LifeCycle extends React.Component {

    // on refreshing
    componentDidMount() {
        // Open a Timer
        this.timerId = setInterval(() => {
            console.log('Timer on going......')
        }, 500)
    }

    render() {
        return <h1>Times of which Tom was beaten: {this.props.count}</h1>
    }

    // Clear timer when the component is uninstalled
    componentWillUnmount() {
        console.warn('LifeCycle hook function: componentWillUnmount')
        clearInterval(this.timerId)
    }
}
```

### High-level components

High-level Component: (*HOC*, higher-Order Component) is a function, which receives the components to be wrapped, and returns the enhanced component. The inner of *HOC* creates a **class component**, in which provides the state and logic resolving codes that can be reused, and it passes the state and logic to the **WrappedComponent** via **prop**.

+ Purpose: To realize recycle of states and logic.
+ Utilizes **Wrapping** mode: 
+ For example: Phone, acquires protection. Phone shell: Provide protection. High-level components is like a phone shell, enhances functions of components by wrapping them.

Steps:

1. Write a function, which is headed with ***with***.

2. Set the designated function, which needs to be fronted by a capital letter (To use as the component to be rendered).
3. Create a class inside the function, which provides the logic and state to be reused, and return it.
4. In this component, it renders the passed-in component, and passes the state via **props**.
5. Call this *HOC*, and pass in the necessary component, get the enhanced component via the return value, and render it in the webpage.

In the below example, we realizes a function to capture the position of our mouse:

```jsx
import React from "react";
import ReactDom from 'react-dom'
import img from './img/cat.jpg'

/*
* High level component
*
*/

// Create a high-level component
function withMouse(WrappedComponent){
    class Mouse extends React.Component{
        // State of the mouse:
        state = {
            x: 0,
            y:0
        }

    	// mouse position handler
        handleMouseMove = e => {
            this.setState({
                x:e.clientX,
                y:e.clientY
            })
        }

        // control the state of the mouse
        componentDidMount() {
            window.addEventListener('mousemove', this.handleMouseMove)
        }

        // Untie the event handler
        componentWillUnmount() {
            window.removeEventListener('mousemove', this.handleMouseMove)
        }

        // Pass the state by props to the function to be wrapped
        render(){
            return <WrappedComponent {...this.state} />
        }
    }
    return Mouse
}

// call the HOC
const Position = props => (
    <p>
        Current Mouse Position: (x: {props.x}, y: {props.y})
    </p>
)

// obtain enhanced component
const MousePosition = withMouse(Position)

// Cat catch mouse
const Cat = props => (
    <img src={img} alt="" style={ {
        position: "absolute",
        top: props.y +350
        ,
        left: props.x - 64,
        width: 100,
        height: "auto" 
    } } />
)

const CatWithMouse = withMouse(Cat)

class HOC extends React.Component {
    render() {
        return(
            <div>
                <h1>
                    high-level component
                    {/* Enhanced component */}
                    <MousePosition />
                    <CatWithMouse />
                </h1>
            </div>
        )
    }
}

ReactDom.render(<HOC />, document.getElementById('HOC'))import React from "react";
```

#### Setup DisplayName for passed in components

+ Problems when using *HOC*: The names of passed in functions are the same, It is impossible to distinguish different function when they are all passed in the same high-level component.
+ Reason: In the default condition, *React* uses component name as **DisplayName**.
+ Solution: Setup ***displayName*** for high-level components to distinguish them when debugging. (In *React dev tool*)

```jsx
// Set display name
Mouse.displayName = `WithMouse${getDisplayName(WrappedComponent)}`

// getDisplayName of function
function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component'
}
```

### React Component Sum

+ Communication between components are the necessary part in building a React app
+ **props** is the key to parameter transferring between components
+ State promotion is the usual way of communication
+ **Hook Function** can be executed at particular time to get special jobs done
+ Simple model of components: **(state, props) => UI**



## Principles in React 

###  Asynchronization of `SetState()`

+ Cautious: When using this function, the `setState()` on the back is independent of the results of the front `setState()`, although it can be called multiple times in a class. 

+ We can call multiple times of `setState()`, but it will only trigger `render()` once.

+ Recommended syntax: 

  ```jsx
   this.setState((state, props) => {
              return {
                  count: state.count + 1
              }
              })
  ```

  + Usage: `this.setState((state,props) => {})`
  + parameter `state`: the newest `state`
  + parameter `props`: the newest `props`

### Second parameter of `setState()`

+ Circumstance: When the page refreshing is done, it will be executed

+ syntax: `setState(updater, [callback])`

  ```jsx
  onIncrement=() => {
      console.log("clicking....")
      // Asynchronization, not recommended
      // this.setState({
      //     count: this.state.count + 1
      // })
  
      // Recommended:
      this.setState((state, props) => {
          return {
              count: state.count + 1
          }
          },
          // execute after the page is refreshed
          () => {
          console.log('Refreshing accomplished: ', this.state.count)
              document.title = 'Title after refreshing: ' + this.state.count
          })
      console.log(this.state.count) // less 1 
  }
  ```

  <img src="https://img-blog.csdnimg.cn/8ed6af37f1dc4b14b39ee1ce8c8967d0.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="setStateResult" style="zoom:60%;" />

  <img src="https://img-blog.csdnimg.cn/be50ea29cdff4a3c8cf70aecb7b2e3e1.PNG" alt="titleResultofSetState" style="zoom:60%;" />

The picture shows that call back function happens right after the rendering is done. 

#### Transfer process of ***JSX*** syntax

+ ***JSX*** is a simplized syntax of `createElement()`
+ ***JSX*** syntax is compiled as `createElement()` by *@babel/preset-react*
+ *React* element: is a object, to describe what you see on the screen
+ ***JSX*** syntax => `createElement()` => *React* element

## React Router

Modern front-end applications are usually **SPA** (Single Page Application), that is to say the application has only one page of *HTML*. Due to its light-weighted body, low pressure for server, it is popular. To better utilize the technique that one *HTML* controls multiple pages, **front-end router** is born.

+ Function of **front-end router** : navigate from one view (page) to another view (page)
+ **front-end router** is series of rules which defines mapping. In ***React***, it is demonstrated as  the relation between **URL** and **Components**.

Basic steps:

1. Install via `npm i react-router-dom`
2. Import three core component: ***Router/Route/Link***
3. Wrap the whole component through **Router** component
4. Make a navigate menu via **link component** (Routing entrance)

This is the basic router of React:

```jsx
import React from "react";
import ReactDOM from 'react-dom'


import {BrowserRouter as Router, Route, Link} from "react-router-dom";

const First = () => <p>This is the content of the first page</p>

// Wrap the whole component by <Router></Router>
class BasicRouter extends React.Component {
    render() {
        return(
            <Router>
                <div>
                    <h1>This is the basic react router</h1>

                    {/* designate the entrance of the router */}
                    <Link to="/first"> Page one</Link>

                    {/*  designate the exit of router  */}
                    <Route path="/first" component={First}/>
                </div>
            </Router>
        )
    }
}

ReactDOM.render(<BasicRouter />, document.getElementById('Router'))
```

### Router description

+ **Router** component: It wraps the whole application, and one **React** App only need to use it once.

+ Two Basic Router: **BrowsRouter** && **HarshRouter**.

+ HashRouter: Realize through the hash value of the *URL* (localhost:3000/#/first)

+ **Link**: To use as the entrance (href) of the router (a tag)

  ```jsx
  // to: pathname (location.pathname) in the browser url braket  
  <Link to="/first"> Page one</Link>
  ```

+ **Route**: To show the related information of the designated router

```jsx
// path: Routing rule
// component: The components to be described
// can decide where the routing component is placed
<Route path="/first" component={First}/>
```

### Logical Routing

+ Circumstance: When clicking the login button, it jumps to the login page. After the login is done, it jumps back.
+ Programmable routing: Page routing through ***JS*** code.
+ `push(path)`: Jump to a particular page, `path` indicates the path to be jumped to
+ `go(n)`: Forward or back to a particular page, n indicates the number of pages to move (-1 is represented as move back to the last page)

The below example shows a simple page containing the function of login and return to home page. When hitting the button *Go to the login page*, it displays the login page:

<img src="https://img-blog.csdnimg.cn/9bb3d4cec51246068e2310b2ec439b34.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hoaGhoYW9oYW8=,size_16,color_FFFFFF,t_70" alt="loginPage" style="zoom:60%;" /><img src="D:\pc\Pictures\loginPage1.PNG" alt="loginPage1" style="zoom:60%;" />

<center>Login page after clicking the button</center>

Then, when hitting *Hit me to Login~* it displays the home page:

<img src="https://img-blog.csdnimg.cn/1c8c1afdb26a4aa1b16d0b2a86fad8c2.PNG" alt="Homepage" style="zoom:60%;" /><img src="D:\pc\Pictures\homePage1.PNG" alt="homePage1" style="zoom:60%;" />

<center>Home page after login</center>

```jsx
import React from "react";
import ReactDOM from "react-dom"

import {BrowserRouter as Router, Route, Link} from "react-router-dom";

class Login extends React.Component {

    handleLogin = () => {
        // routing jump
        this.props.history.push('/home')

    }

    render() {
        return (
            <div>
                <p>
                    This is the login page!!
                </p>
                <button onClick={this.handleLogin}>
                    Hit me to Login~
                </button>
            </div>
        )
    }
}

const Home = props => {

    const handleBack = () => {
        // go(-1) indicates to go to the last page
        props.history.go(-1)
    }
    return (
        <div>
            <h2>
                This is the home page
            </h2>
            <button onClick={handleBack}>Return to the login page~</button>
        </div>
    )
}


const AppLogin = () => (
    <Router>
        <div>
            <h1>
                programmable routing:
            </h1>
            <Link to="/login">
                Go to the login page
            </Link>
            <Route path="/login" component={Login}/>
            <Route path="/home" component={Home}/>
        </div>
    </Router>
)

export default AppLogin
```

### Default Route

+ The default path is: `/`

  ```jsx
  <Route path="/" component={Home} />
  ```

  However, when we use other routes, this default router will be filtered out. This is because React router is a approximate string matching, the routers will be found as long as the string is the beginning of the routing pattern.

  | Path   | pathname to be matched                                       |
  | ------ | ------------------------------------------------------------ |
  | /      | all the pathes                                               |
  | /first | ***/first*** or ***/first/a*** or ***/first/a/b ......*** ...... |

  

  To get rid of this condition, we need apply exact matching:

+ Add ***exact*** entity in **Route** component, it will become exact matching mode

+ **Exact matching:** Only when ***path*** is exactly the same as ***pathname***, it will be matched to the router

  ```jsx
  // now, this component will only match pathname="/" this exact condition
  <Route exact path="/" component=... />
  ```

  
