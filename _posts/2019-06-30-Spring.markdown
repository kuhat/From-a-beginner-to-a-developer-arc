---
layout: post
title:  "Spring Framework"
description: An introduction of what docker is.
date:   2020-07-22 21:03:36 +0530
---
This post is a start guide of *Spring* framework.

# Overview

 The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.

 A key element of Spring is **infrastructural support at the application level**: Spring focuses on the "plumbing" of enterprise applications so that teams can focus on application-level business logic, without unnecessary ties to specific deployment environments.

 Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release.

 Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server.

 Spring is open source. It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time.

# IOC Container and Beans

 Foremost amongst these is the **Spring Framework’s Inversion of Control** (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of **Spring’s Aspect-Oriented Programming** (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.

## Introduction

 **IoC** is also known as **dependency injection** (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the **inverse** (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using **direct construction of classes** or a mechanism such as the Service Locator pattern.

 The `org.springframework.beans` and `org.springframework.context` packages are the basis for Spring Framework’s **IoC container**. The `BeanFactory` interface provides an advanced configuration mechanism capable of managing any type of object. `ApplicationContext` is a sub-interface of `BeanFactory`.

In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called **beans**. A bean is an object that is **instantiated, assembled, and otherwise managed by a Spring IoC container**. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.

### Container

The `org.springframework.context.ApplicationContext` interface represents the **Spring IoC container** and is responsible for **instantiating, configuring, and assembling the beans**. The container gets its instructions on what objects to instantiate, configure, and assemble by **reading configuration metadata**. The configuration metadata is represented in ***XML***, **Java annotations**, or **Java code**. It lets you express the objects that compose your application and the rich interdependencies between those objects.

Several implementations of the ·ApplicationContext interface· are supplied with Spring. In stand-alone applications, it is common to create an instance of `ClassPathXmlApplicationContext` or `FileSystemXmlApplicationContext`. While ***XML*** has been the traditional format for defining configuration metadata, you can instruct the container to use **Java annotations or code as the metadata format** by providing a small amount of ***XML*** configuration to declaratively enable support for these additional metadata formats.

The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the `ApplicationContext` is created and initialized, you have a fully configured and executable system or application.

![Spring](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/images/container-magic.png)
<center>The Spring IoC container</center>

#### Configuring Metadata

As the preceding diagram shows, the **Spring IoC container** consumes a form of configuration metadata. **This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application**.

Configuration metadata is traditionally supplied in a simple and intuitive ***XML*** format.

**These bean definitions correspond to the actual objects that make up your application**. Typically, you define **service layer objects**, **data access objects** (`DAO`s), presentation objects such as Struts Action instances, infrastructure objects such as Hibernate `SessionFactories`, `JMS Queues`, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of `DAOs` and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See Using AspectJ to dependency-inject domain objects with Spring.

The following example shows the basic structure of **XML-based configuration metadata**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">  
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```

 + The id attribute is a string that identifies the individual bean definition.
 + The class attribute defines the type of the bean and uses the fully qualified
    classname.

#### Instantiating a Container

The location path or paths supplied to an `ApplicationContext` constructor are **resource strings that let the container load configuration metadata** from a variety of external resources, such as the local file system, the Java `CLASSPATH`, and so on.

```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

The following example shows the service layer objects (`services.xml`) configuration file:

```xml


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->

</beans>
```

The following example shows the data access objects `daos.xml` file:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>
```
In the preceding example, the service layer consists of the `PetStoreServiceImpl` class and two data access objects of the types `JpaAccountDao` and `JpaItemDao` (based on the JPA **Object-Relational Mapping standard**). The property name element refers to the name of the **JavaBean** property, and the `ref` element refers to the name of another bean definition. This linkage between `id` and `ref` elements expresses the **dependency** between collaborating objects.

#### Composing XML-based Configuration Metadata

It can be useful to have bean definitions span multiple `XML` files. Often, each individual `XML` configuration file represents a **logical layer or module** in your architecture.

You can use the application **context constructor** to load bean definitions from all these `XML` fragments. This constructor takes multiple Resource locations. Alternatively, use one or more occurrences of the `<import/>` element to load bean definitions from another file or files. The following example shows how to do so:

```xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

In the preceding example, external bean definitions are loaded from three files: `services.xml`, `messageSource.xml`, and `themeSource.xml`. All location paths are relative to the definition file doing the importing, so `services.xml` must be in the **same directory or classpath location as the file doing the importing**, while `messageSource.xml` and `themeSource.xml` must be in a resources location below the location of the importing file. As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level `<beans/>`element, must be valid XML bean definitions, according to the Spring Schema.

#### Using the Container

The `ApplicationContext` is the interface for an advanced factory capable of **maintaining a registry of different beans and their dependencies**. By using the method `T getBean(String name, Class<T> requiredType)`, you can retrieve instances of your beans.

The ApplicationContext lets you read bean definitions and access them, as the following example shows:

```java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```
With **`Groovy` configuration**, bootstrapping looks very similar. It has a different context implementation class which is **Groovy-aware** (but also understands `XML` bean definitions). The following example shows Groovy configuration:

```java
ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
```

The most flexible variant is `GenericApplicationContext` in combination with reader delegates — for example, with `XmlBeanDefinitionReader` for `XML` files, as the following example shows:

```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

You can also use the `GroovyBeanDefinitionReader` for Groovy files, as the following example shows:

```java
GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();
```

You can then use `getBean` to retrieve instances of your beans. The `ApplicationContext` interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the `getBean()` method at all and thus have no dependency on `Spring APIs` at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and `JSF-managed beans`, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).

For example, to generate a simple object "Hello", we can use beans to help create it.

```java
public class Hello {
    private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    @Override
    public String toString() {
        return "Hello{" +
                "str='" + str + '\'' +
                '}';
    }
}
```
In the Resource, there is a new `xml` file called bean.xml and before the creation of the Spring framework, it should load the `.jar`
files from `maven` first.

![Import"jar"FIle](https://thumbnail0.baidupcs.com/thumbnail/6ef0d0d60v0cf4a96fe017f7c5c90651?fid=156850721-250528-4134635253381&time=1595498400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-aaqsFTlD2kqajUOkcni9lCxq%2FEg%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=4749204848576213673&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)
<center>Import ".jar" Files</center>

![XML](https://thumbnail0.baidupcs.com/thumbnail/0fcb47027k544022b0fa7f07f5b20bde?fid=156850721-250528-155151245752296&time=1595498400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2ALsgCNxyRdOWnNz87ySv0lDzNU%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=4749176904738517390&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)
<center>XML file Detail</center>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">


    <!--Using Spring to create objects, Bean is the generator in Spring
    Type  Name  = new Type();
    Hello hello = new Hello();
    id          = name
    class       = new Object;
    property is to assign a value to the object
    -->

    <bean id="Hello" class="Hello">
        <!-- additional collaborators and configuration for this bean go here -->
            <property name="str" value="Spring"/>
    </bean>
    <!-- more bean definitions for data access objects go here -->

</beans>
```

And finally, the testing method looks like what the code below describes:

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class myTest {
    public static void main(String[] args){
        ApplicationContext context = new ClassPathXmlApplicationContext( "bean.xml");
        Hello hello = (Hello) context.getBean("Hello");
        System.out.println(hello.toString());
    }
}
```

